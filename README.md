# Airangel Engineering Challenges
A collection of development challenges for Airangel applicants. For the moment, we have moved to asking all candidates to complete a coding challenge, as code shared from personal projects frequently included compromises which didn't display candidates at their best. At present these are language agnostic and made up solely of readme files. We may move to refactor challenges in future. 

## General Guidance
We will be asking you to talk through your solution during the interview, so please make sure that you have both a running version of your code ready to demonstrate, along with the code itself present to discuss. The criteria we will use to assess the code you present is below. Not all of these will be applicable for every challenge, but please use the criteria to guide your approach.

## Inspiration
These challenges are currently directly based on work done by others, including https://github.com/davidwhitney. 

# Assessment Criteria

## Submission

We will be asking you to talk through your solution during the interview, so please make sure that you have both a running version of your code ready to demonstrate, along with the code itself in your IDE of choice. 

* Before the interview, please supply a link to the hosted repository (e.g. Github, Bitbucket...). We cannot review archives or single files.
* The repo should include a README that follows the [principles described below](#project-readme) In particular, please make sure to include high-level explanation about what the code is doing.
* Ideally, the code you're providing:
  * Has been written by you alone. If not, please tell us which part you wrote and are most proud of in the README.
  * Is leveraging web technologies.
  * If appropriate, is deployed and hosted somewhere. If it cannot be hosted, then setup instructions and dependencies should be supplied. 

## Project Readme

You must include a readme. Write your README as if it was for a production service. Include the following items:

* Description of the problem and solution.
* Whether the solution focuses on back-end, front-end or if it's full stack.
* Reasoning behind your technical choices, including architectural. 
* Trade-offs you might have made, anything you left out, or what you might do differently if you were to spend additional time on the project.

Optionally, you may also wish to include:

* Link to other code you're particularly proud of.
* Link to to the hosted application where applicable.

## How we review

Your application will be reviewed by at least three of our engineers. We do take into consideration your experience level.

**We value quality over feature-completeness**. It is fine to leave things aside provided you call them out in your project's README. The goal of this code sample is to help us identify what you consider production-ready code. You should consider this code ready for final review with your colleague, i.e. this would be the last step before deploying to production.

The aspects of your code we will assess include:

* **Architecture**: how clean is the separation between the front-end and the back-end?
* **Clarity**: does the README clearly and concisely explains the problem and solution? Are technical tradeoffs explained?
* **Correctness**: does the application do what was asked? If there is anything missing, does the README explain why it is missing?
* **Code quality**: is the code simple, easy to understand, and maintainable?  Are there any code smells or other red flags? Does object-oriented code follows principles such as the single responsibility principle? Is the coding style consistent with the language's guidelines? Is it consistent throughout the codebase?
* **Security**: are there any obvious vulnerability?
* **Testing**: how thorough are the automated tests? Will they be difficult to change if the requirements of the application were to change? Are there some unit and some integration tests?
	* We're not looking for full coverage (given time constraint) but just trying to get a feel for your testing skills.
* **UX**: is the web interface understandable and pleasing to use? Is the API intuitive?
* **Technical choices**: do choices of libraries, databases, architecture etc. seem appropriate for the chosen application?

Bonus point (those items are optional):

* **Scalability**: will technical choices scale well? If not, is there a discussion of those choices in the README? 
* **Production-readiness**: does the code include monitoring? logging? proper error handling?


## Original source
The assessment criteria are based on Uber's [coding challenge assessment criteria](https://github.com/uber-archive/coding-challenge-tools). 


